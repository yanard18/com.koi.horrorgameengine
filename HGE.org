* Project
1. If any change requested, requester must offer an alternative idea.
2. User documentation should ve written integrated to development of the project.
3. Code must be documentad as well via [[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments][documentation-commenting]].
4. First viable version must be implemented for Singleplayer & FPS

** Project Summary
Horror Game Engine is a game development kit primarly designed for FPS games that let developers develop
horror games without any programming however still extendible for programmers as well.

* Requirements

** Functional Requirements

- FPS Player Movement
- Scene Management
- Sound Engine
- Game Effect Manager
- AI Agent
- Trigger Mechanic
- Tetris Inventory
- Single Inventory
- Flashlight
- Battery Power System
- Cameras (CCTV like)
- Doors
- Camera like HUD
- Head-Bob system
- Behaviour Tree
- AI Builder
- Quest System
- Puzzle System
- Inspect
- Interaction
- Hiding
- Options Menu
- Input System
- Dialogue System
- Cutscene Manager
- Shop System
- Health System
- Drag System
- Documentation
- Slender The Eight Pages Demo
  
*** FPS Player Movement
FPS player movement is the core element of the horror game engine. Also start point of the project. One monolithic class that we can warmup as a team.
It will also reflect what other classes we will need in the future. I.e., step sound implementation will reveal the need of *sound engine*.

Make a design decision before start, how the player hand should be implemented. Procedural, blender exported or hybrid?
Write user requirements to identify various needs of FPS hand.

Multiplayer integration must start at this point. It's wise to analyze Unity's builtin multiplayer solution with classic FPS movement code in order to
make our singleplayer design extendible for future.

Do not forgot to documentate the code while develop.

*Functional Sub-Requirements*:
1. Jump
   1. Remember jump input (if input released 0.1 sec ago; still should jump)
   2. Remember ground leave (if leave ground 0.1 sec ago; still should jump)
2. Crouch
3. Acceleration and Deacceleration
4. Slope Climb Configuration
5. Slap Movement
6. Run
7. Stamina
8. Prone
9. Head Bob
10. Lag Camera Movement
11. Customizable FPS Hand
13. Step Sound

*System Sub-Requirements*
1. Documentated
2. Multiplayer Extendibility
   
*** Scene Management
How we load scenes is a important process of designing a framework. We can (and probably should) enforce a rigid system to load and play scenes.
Unreal Engine has a similar system called "experiences".
But more importantly it will define that how we will initiate the dependencies. I.e., a dependency injection like system.

*Functional Sub-Requirements*:
1. Async level loading and unloading
2. Dependeny intialization
3. Handling persistent objects
4. Player start logic
5. Multiplayer compatible

*** AI Agents
AI Agent mechanic is the area that we want to put extra effort. Developers must be able to design AI characters without need of programming.

1. Classic AI characters must be implementable without coding
2. AI Sensing modules
3. AI Movement modules
4. AI Path Finding
5. Unreal Engine inspired EQS system
6. Behaviour Tree
   1. Behaviour Tree's graph editor can be used in other tools in future

*** Quest System

*** Sound Engine
Analyze great sound engines from other projects like Gta V source code or FMOD Unity asset
1. Atmoshperic Sound
2. Object Pooling for spawning audio emitters
3. Alternative method to find audio cues end emit audio on them instead of spawning from pool 
*** Dialogue System
1. Different languages support
*** Doors
1. Physic base doors
2. Control door with mouse movement
3. Classic interact-open doors

** Optional Functional Requirements
- TPS Mechanic
- Procedural Asset Placement
- Procedural Environment Generation
- Forge AI Integration

** Non-Functional Requirements
1. Interfaces must provide optional usages. I.e., if sound engine prefer dynamic audio cue spawn, also add
   alternative functions to run audio cues on already placed audio componenst (non dynamic spawn)
2. Each game system must be usable and configurable without any need of programming however systems must be extendible
   for programmers who wants to extend the code.
3. Different systems should share similar UI interfaces to remove duplication and increase consistency.
4. Use Unity's New UI toolkit for both main menu UI and custom editor UI.
5. Apply Unit Testing.
6. Designs must be competible for future development of multiplayer integration.

* Project Risk Management
** Riskes
- R0: Can not find royalty free sound assets
- R1: Sales goes under 100$ per month
- R2: Final design is not multiplayer extendible
- R3: Development not finished in two months.

** Pre-active Plan to Prevent
- R0: Documentate what sounds will be required before release.
- R1: Check [[#Sales Plan]] header.
- R2:
- R3: Milestones and time estimation.

** If Risk Happens
- R0: Releasing packet without sounds or buy from fiverr
- R1:
- R2: 
- R3: 
- R4: 
  
* Naming Conventions
** Folder Structure
#+BEGIN_SRC text
<package-root>
  ├── package.json
  ├── README.md
  ├── CHANGELOG.md
  ├── Third Party Notices.md
  ├── Prefabs
  ├── Editor
  │   ├── <organization-name>.<package-name>.Editor.asmdef
  │   └── EditorExample.cs
  ├── Runtime
  │   ├── <organization-name>.<package-name>.asmdef
  │   └── RuntimeExample.cs
  ├── Tests
  │   ├── Editor
  │   │   ├── <organization-name>.<package-name>.Editor.Tests.asmdef
  │   │   └── EditorExampleTest.cs
  │   └── Runtime
  │        ├── <organization-name>.<package-name>.Tests.asmdef
  │        └── RuntimeExampleTest.cs
  ├── Samples
  │        ├── Example
  │        └── ...
  └── Documentation
       └── <package-name>.(md or html)
#+END_SRC
Documentation:
This folder contains user documentation of the project.
1. This folder must contain one markdown file
2. Or host the documentation online
refer: https://docs.unity3d.com/6000.3/Documentation/Manual/cus-document.html

Samples:
Follow the UPM file struce provided as in Unity docs.
refer: https://docs.unity3d.com/6000.3/Documentation/Manual/cus-samples.html

** Asset Naming Conventions

| Asset Type           | Prefix | Suffix (or description)                        |
|----------------------+--------+------------------------------------------------|
| Prefab               |        |                                                |
| Material             | M_     |                                                |
| Material Instance    | MI_    |                                                |
| Physic Material      | PM_    |                                                |
| Texture Albedo       | T_     | _A                                             |
| Texture Normal       | T_     | _N                                             |
| Texture Height       | T_     | _B                                             |
| Texture Emissive     | T_     | _E                                             |
| Texture Metallic     | T_     | _M                                             |
| Texture Roughness    | T_     | _R                                             |
| Texture Mixed        | T_     | _MRH (prefix ordered by channels)              |
| Shaders              | SH_    |                                                |
| Audio Cues           | AC_    |                                                |
| Audio Mixer          | MIX_   |                                                |
| Skeletal Mesh        | SK_    | (Assets with bone system are skeletal meshes)  |
| Static Mesh          | SM_    | (Assets without bone system are static meshes) |
| Animation Clip       | A_     |                                                |
| Animation Controller | AC_    |                                                |
| Avatar Mask          | AM_    |                                                |
| Particle System      | PS_    |                                                |

** Git Structure
*** Branches
1. Use master branch only when the feature is fully complete and safe (HAHA what's unsafe in c#???)
2. Main branch is =master=.
3. Second branch is =master/develop=, behave as a safe layer before pushing fetures to master.
4. Third branch is =develop/feature=, for each future use a separate feature branch.
*** Commits
a. Commits must be atomic.
b. Each commit name must be written in impretive mood.

** Code Convention
In general follow [[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions][.NET Common C# Conventions]]
For naming convention follow [[https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names][.NET Naming Conventions]]

** Task Management
Prefer simple. Use whatsapp for communication and do not use any task management tool.
However each feature must have its own branch, which indicates the WIP feature.
Commit names must be clear and atomic.
Still GitHub issues can be used to note down a feature or a bug.

** File Management
Use Google Drive for external files (references, external docs, blender files...).
Use Google Drive for file sharing.
Use Git LFS for project's repo.


* Milestones

Handle this on a google sheet later.

* Sales Plan
:PROPERTIES:
:CUSTOM_ID: Sales Plan
:END:

1. Publish the packet in Unity Asset Store
2. Use Reddit for taking feedback
3. Offer developers to join alpha version to test the product in return of giving feedbacks

